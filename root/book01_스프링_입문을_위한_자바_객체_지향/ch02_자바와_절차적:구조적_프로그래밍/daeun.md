# ch02. 자바와 절차적/구조적 프로그래밍

## 자바에 존재하는 절차적/구조적 프로그래밍의 유산

자바에서는 goto 사용을 못하게 한다.

goto문은 제어 흐름을 이리저리 이동시키는 용도인데,

goto를 이용한 이동은 프로그램을 논리적으로 잘 구성하면 모두 피할 수 있는 것이기 때문이다.

### 구조적 프로그래밍

- 중복 코드를 한 곳에 모아 관리
- 논리를 함수 단위로 분리해 이해하기 쉬운 코드를 작성할 수 있음.
- 공유 사용 시 문제가 발생하기 쉬운 전역 변수보다는 지역 변수를 쓰라는 것도 있음.

## 메서드 스택 프래임

Start.java

```java
public class Start {
	public static void main(String[] args) {
		System.out.println("Hello OOP!!!"); // 3
	}
}
```


**힙영역**은 OOP에서 클래스와 객체를 이야기한 이후에 다뤄진다.

### **JRE**

1. 프로그램 안에 main() 메서드가 있는지 확인
2. Start 클래스에서 main() 메서드 발견
3. 프로그램 실행 사전 준비 착수, JVM 부팅

### **JVM**

**전처리 과정**

1. 목적 파일 실행
2. java.lang 패키지(모든 자바 프로그램이 반드시 포함하게 되는 패키지) 스태틱 영역에 push
    - lang 패키지에 포함되는 클래스들

        ```java
        String, StringBuffer
        Process, Runtime, Thread
        Math, StrictMath
        Exception Throwable, Error
        Package, Class, ClassLoader
        Wrapper, System, Stream
        ```

3. 개발자가 작성한 모든 클래스와 임포트 패키지를 스태틱 영역에 push

## 변수와 메모리

start2.java

```java
public class Start2 {
	public static void main(String[] args) {
		int i; // 1
		i = 10;
		double d = 20.0;
	}
}
```

**JRE와 JVM이 하는 일은 위의 연장선**

### JVM

1. main() 메서드 내에 있으니 스택 프레임 안에 밑에서부터 변수 공간을 마련함.
(4바이트 크기의 정수 저장 공간)
2. 그 후 그 공간에 10을 할당함.
3. 변수를 선언 + 할당함.

## 블록 구문과 메모리

```java
public class Start3 {
	public static void main(String[] args) {
		int i = 10;
		int k = 20;
		if(i == 10) { // 1
			int m = k + 5;
			k = m;
		} else {
			int p = k + 10;
			k = p;
		}
			//k = m + p;
	}
}
```

### JVM

위와 동일한 방식으로 스택 프레임에 변수가 선언 + 할당됨.

1. 1번 구문을 실행할 때, 스택 프레임은 if문 블록의 스택 프레임이 생김.
2. 해당 스택 프레임에 변수 m의 공간을 마련하면서 선언 + 할당됨.
3. if 블록을 종료하는 닫는 중괄호를 만나면 if문 블록의 스택 프레임은 스택 영역에서 사라짐.
4. m은 지역 변수이므로 메모리에서 사라짐.

## 메서드 호출과 메모리

```java
public class Start4 {
	public static void main(String[] args) {
		int k = 5;
		int m;
		m = square(k);	
	}

	private static int square(int k) {
		int result;
		k = 25;
		result = k;
		return result;
	}
}
```

### JVM

1. square() 메서드의 시작 중괄호를 실행함과 동시에 square() 스택 프레임이 생성됨.
2. 위와 같은 방식으로 변수가 선언 + 할당됨.
3. main() 메서드가 가진 변수 k와 square() 메서드가 가진 변수 k는 별도의 변수 공간으로 영향이 없다.
4. 닫는 중괄호를 만나면 square() 메서드 스택 프레임은 스택에서 사라진다.(반환값을 돌려주면서)
5. main 메서드내에서 square 메서드 내에 존재하는 지역 변수에는 접근할 수 없다.
각기 다른 독립적인 스택 프레임으로 구성되기 때문.
    - 전역변수

        전역변수는 스택 프레임에 독립적이며 스태틱 영역에 종속되어있기에 여러 메서드들이 공유할 수 있다.

        그러나 읽기 전용으로 값을 공유해서 전역 상수로 쓰지 않는 이상은 전역 변수를 쓰는 것은 추천되지 않는다.

        큰 프로젝트의 경우 해당 전역 변수가 변경되었는지 여부를 알기 어려우며, 관리하기 어렵기 때문이다.

6. main() 메서드 닫히는 중괄호를 실행하면, 해당 메모리 소멸, JVM 가동 중지, JRE가 사용했던 시스템 자원을 운영체제에 반납한다.

## 멀티 프로세스 / 멀티 스레드

### 멀티 스레드

스택 영역을 스레드 개수만큼 분할해서 쓴다. (메모리를 공유한다.)

시스템 자원을 절약할 수 있다.

스택 영역이 독립적으로 나누어져 있는 이유 → 독립적인 함수 실행을 위해 공유하지 않는다.

멀티 스레드에서는 전역 변수를 쓰지 않아야 한다. 쓰기 가능한 전역 변수를 쓰게 되면 동기화를 보장할 수 없다. lock을 거는 것은 멀티 스레드를 하는 의미가 없기에 쓰지 않는 게 좋다.

### 멀티 프로세스

다수의 데이터 저장 영역을 갖는 구조다. (스태틱, 힙, 스택영역)

하나의 프로세스가 죽더라도 다른 프로세스는 영향을 미치지 않고 정상적으로 수행되나, 죽은 프로세스가 하던 일을 해야하므로 성능은 느려진다.