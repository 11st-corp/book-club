# ch04. 자바가 확장한 객체 지향
## abstract 키워드 - 추상 메서드와 추상 클래스

### 목적

- 추상 메소드가 포함된 클래스를 상속받는 자식 클래스가 반드시 추상 메소드를 구현하도록 하기 위함.
- 모듈처럼 중복되는 부분이나 공통적인 부분은 미리 만들어진 것을 사용하고, 이를 받아 사용하는 쪽에서는 자신에게 필요한 부분만을 재정의 하여 사용함으로써 생산성이 향상되고 배포 등이 쉬워짐.

### 추상 클래스는 왜 객체를 생성할 수 없을까?

- 선언부만 있는 추상 메소드를 포함하므로 인터페이스 객체를 생성할 수 없듯이 추상 클래스 또한 그렇다.

## 생성자

- new 클래스 명()
- 개발자가 생성자를 만들지 않는다면 자바는 인자가 없는 기본 생성자를 자동으로 만들어 줌.

## 클래스 생성 시의 실행 블록, static 블록

- 클래스가 스태틱 영역에 배치될 때 실행되는 코드 블록 → static 블록
- 해당 클래스가 코드에서 맨 처음 사용될 때 T 메모리의 스태틱 영역에 로딩됨.

### 처음 사용되는 기준

- 클래스의 정적 속성을 사용할 때
- 클래스의 정적 메서드를 사용할 때
- 클래스의 인스턴스를 최초로 만들 때

## final 키워드

### 대상

- 클래스 → 상속을 허락하지 않는다.
- 변수 → 변경 불가능한 상수가 된다.
- 메서드 → 오버라이딩을 금지한다.

## instanceof 연산자

- 만들어진 객체가 특정 클래스의 인스턴스인지 물어보는 연산자
- 객체_참조_변수 instanceof 클래스명
- true나 false를 리턴

## interface & implements 키워드

- public 추상 메서드와 public 정적 상수만 가질 수 있다.
- 따로 메서드에 public 과 abstract, final을 붙이지 않더라도 자동으로 자바가 붙여줌.
- 함수형 프로그래밍
    - 반응형 프로그래밍의 기초가 됨.
    - 선언적, 어플리케이션의 상태 흐름이 순수 함수를 통해 흐름.
    - 순수함수
        - 주어진 입력으로 계산하는 것 이외에 프로그램의 실행에 영향을 미치지 않아야 함.(side effect x)
        - input: 함수에서 외부의 데이터를 직접적으로 사용하지 않고 파라미터로 받는다.
        - output: input 값에 의해 output이 결정되므로 외부의 값들이 변경되더라도 함수 자체에는 외부에 영향을 받지 않기에 side effect가 없음.
        - 재사용성이 높아짐.
        - 코드 블록을 이해하기 위해 일련의 상태 갱신을 따라갈 필요가 없고 국소 추론 만으로도 코드를 이해할 수 있음.
        - 순수 함수와 순수 함수가 아닌 것

        ```jsx
        // 순수 함수
        add = (a, b) => a + b;
        console.log(add(10, 5));
        // 전반적인 흐름을 따라가지 않고도 구현체만 확인함으로써 코드 이해 가능.
        ```

        ```jsx
        // 순수 함수 X
        var c = 10;
        add2 = (a, b) => a + b + c;
        console.log(add2(10, 3));
        console.log(add2(10, 3));
        c = 20;
        console.log(add2(10, 3));
        // 함수 내에서 외부 c 변수가 변하면 결과 값도 달라짐.
        ```

## this 키워드

- 객체 멤버 메서드 내부에서 객체 자신을 지칭하는 키워드
- 지역 변수와 속성의 이름이 같은 경우 지역 변수가 우선한다.
- 객체 변수와 이름이 같은 지역 변수가 있는 경우 객체 변수를 사용하려면 this를 접두사로 사용한다.
- 정적 변수와 이름이 같은 지역변수가 있는 경우 정적 변수를 사용하려면 클래스명을 접두사로 사용한다.

## super 키워드

- 바로 위 상위 클래스의 인스턴스를 지칭하는 키워드

## 팁

힙 영역 메모리에 만들어진 객체의 메소드를 각각으로 저장하는 것은 심각한 메모리 낭비로, 실질적으로 객체 멤버 메서드는 스태틱 영역에 단 하나만 보유한다. 그리고 해당 메서드를 호출할 때 객체 자신을 나타내는 this 객체 참조 변수를 넘긴다.