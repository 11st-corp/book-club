
# ch05. 객체 지향 설계 5원칙 - SOLID

> 클린 소프트웨어 Part 2 애자일 설계
> UML 실전에서는 이것만 쓴다 6장 객체 지향 개발의 원칙
> 객체 지향 SW 설계의 원칙 참조

## SRP: 단일 책임 원칙

**어떤 클래스를 변경해야하는 이유는 오직 하나뿐이어야 한다.**

역할과 책임을 분리해라.

> 속성, 메서드, 패키지, 모듈, 컴포넌트, 프레임워크 등에 적용

```java
// 단일 책임 원칙을 지키지 않았을 때
class 환자 {
	final static Boolean 땅콩_알레르기_있는_환자 = true;
	final static Boolean 땅콩_알레르기_없는_환자 = false;
	Boolean 땅콩_알레르기;

	void 땅콩먹다(){
		if(this.땅콩_알레르기 == 땅콩_알레르기_있는_환자) {
			// 알레르기 반응을 보인다.
		} else {
			// 알레르기 반응을 보이지 않는다.
		}
	}
}
```

```java
// 단일 책임 원칙을 지켰을 때
abstract class 환자 {
	abstract void 땅콩먹다()
}

class 땅콩_알레르기_있는_환자 extends 환자 {
	void 땅콩먹다() {
		// 알레르기 반응을 보인다.	
	}
}

class 땅콩_알레르기_없는_환자 extends 환자 {
	void 땅콩먹다() {
		// 알레르기 반응을 보이지 않는다.	
	}
}
```

## OCP: 개방 폐쇄 원칙

**소프트웨어 엔티티(클래스, 모듈, 함수 등)은 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다.**
![](https://i.imgur.com/3a0L6v2.png)


100개의 메소드를 갖고 있는 클래스라고 가정하고, 50개의 메소드를 수정해야 한다고 치면 굉장히 유지보수가 힘들 수 있다.

따라서 상위 클래스와 인터페이스를 중간에 둠으로써 다양한 자동차가 생긴다고 해도 운전 습관에 영향을 받지 않게 될 수 있다.
![](https://i.imgur.com/aZsm8Zb.png)


JDBC를 사용하는 클라이언트는 데이터베이스가 오라클에서 MySQL로 바뀌더라도 Connection을 설정하는 부분 외에는 따로 수정할 필요가 없다.
![](https://i.imgur.com/aPhbN3x.png)


## LSP: 리스코프 치환 원칙

**서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다.**

- 하위 클래스 is a kind of 상위 클래스
- 구현 클래스 is able to 인터페이스

`동물 뽀로로 = new 펭귄()`

상속이 조직도나 계층도 형태로 구축되는 경우는 잘 구현되지 않은 경우이다.

`아버지 춘향이 = new 딸()`

## ISP: 인터페이스 분리 원칙

**클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다.**

![](https://i.imgur.com/urkok0H.png)

빈약한 상위 클래스일 경우 공통적으로 가지고 있는 것들을 상위 클래스에서 구현하지 않았다.

```java
// 빈약한 상위 클래스
public class Driver {
	public static void main(String[] args) {
		사람 김학생 = new 학생("김학생", new Date(2000, 01, 01), "20000101-1234567", "20190001");
		사람 이군인 = new 군인("이군인", new Date(19998, 12, 31), "19981231-1234567", "19-12345678");
		
		System.out.println(김학생.이름);
		System.out.println(이군인.이름);
		
		System.out.println(김학생.생일); // err 캐스팅 필요 ((학생)김학생).생일
		System.out.println(이군인.생일); // err
	}
}
```

상속의 혜택을 제대로 누리지 못하고 있다.

```java
public class Driver {
	public static void main(String[] args) {
		사람 김학생 = new 학생("김학생", new Date(2000, 01, 01), "20000101-1234567", "20190001");
		사람 이군인 = new 군인("이군인", new Date(19998, 12, 31), "19981231-1234567", "19-12345678");
		
		System.out.println(김학생.이름);
		System.out.println(이군인.이름);
		
		System.out.println(김학생.생일);
		System.out.println(이군인.생일);

		System.out.println((학생)김학생).학번); // 캐스팅 필요.
		System.out.println((군인)이군인).군번);
	}
}
```

공통된 속성은 불필요한 형변환을 하지 않아도 되는 것을 볼 수 있다.

## DIP: 의존 역전 원칙

**고차원 모듈은 저차원 모듈에 의존하면 안된다. 두 모듈 모두 다른 추상화된 것에 의존해야한다.**

![](https://i.imgur.com/UYhdDTL.png)

자동차가 구체적인 타이어들이 아닌 추상화된 타이어 인터페이스에만 의존하게 함으로써 다른 구체적인 타이어로 변경해도 자동차는 영향을 받지 않는다.

**자신보다 변하기 쉬운 것에 의존하지 마라.**