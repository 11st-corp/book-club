# Ch.05 책임 할당하기
데이터 중심의 설계에서의 문제점은

- 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.
- 데이터를 먼저 결정하고 데이터를 처리하는 데 필요한 오퍼레이션을 나중에 결정하게 되어, 데이터에 관한 지식이 객체의 인터페이스에 고스란히 드러나게 된다. 따라서 구현을 캡슐화하는 데 실패하고 코드는 변경에 취약해진다.

실은 책임에 초점을 맞춰서 설계할 때, 어떤 객체에게 어떤 책임을 할당할지를 결정하는 것은 쉽지 않다. 따라서 이번 장에서 살펴볼 GRASP 패턴은 책임 할당의 어려움을 해결하기 위한 답을 제시해 줄 것이다.

## 책임 주도 설계를 향해

### 데이터보다 행동을 먼저 결정하라

객체는 협력에 참여하기 위해 존재하며 협력 안에서 수행하는 책임이 객체의 존재를 증명한다.

- 데이터 중심의 설계에서는 "이 객체가 포함해야 하는 데이터가 무엇인가"를 결정 후 "데이터를 처리하는데 필요한 오퍼레이션은 무엇인가"를 결정한다.
- 그러나 책임 중심의 설계에서는 "이 객체가 수행해야 하는 책임은 무엇인가"를 결정하고, "이 책임을 수행하는 데 필요한 데이터는 무엇인가"를 결정한다.

가장 중요한 것은 **적절한 객체에게 적절한 책임을 할당하는 능력**이다.

### 협력이라는 문맥 안에서 책임을 결정하라

책임은 객체의 입장이 아닌, **객체가 참여하는 협력**에 적합해야한다.

- 메시지를 전송하는 클라이언트의 의도에 적합한 책임을 할당해야한다.

  메시지를 결정한 후 객체를 선택해야 한다. 객체가 메시지를 선택하는 것이 아닌, 메시지가 객체를 선택하게 해야한다.

- 객체를 결정하기 전에 객체가 수신할 메시지를 먼저 결정한다.

이로써 협력이라는 문맥 안에서 메시지에 집중하는 책임 중심의 설계는 캡슐화의 원리를 지키기가 쉬워진다.

### 책임주도 설계

앞서 설명한 두 원칙은 책임 주도 설계 방법의 핵심과 거의 동일하다.

1. 책임을 할당한다는 것은 메시지의 이름을 결정하는 것과 같다.
    - 예매하라
2. 메시지를 처리할 적절한 객체를 선택한다.

   → 책임을 수행하기 위해 필요한 정보를 충분히 알고 있는 객체를 선택해야한다.

    - Screening
3. 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 or 역할을 찾는다.
4. 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.
5. 다음 작업 또한 위의 순서대로 수행한다.

## 책임 할당을 위한 GRASP 패턴

영화 예매 시스템을 책임 중심으로 설계하는 과정을 따라가보자.

### 도메인 개념에서 출발하기

어떤 책임을 할당해야할 때 가장 먼저 고민해야하는 유력한 후보는 바로 도메인 개념이다.

도메인은 책임을 할당받을 객체들의 종류와 관계에 대한 정보를 제공할 수 있도록 한다. (너무 많은 시간을 들이지 않도록 해야 함)

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/494ab1b8-f87b-48db-a0e5-4e203e528418/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/494ab1b8-f87b-48db-a0e5-4e203e528418/Untitled.png)

### 정보 전문가에게 책임을 할당해라

1. 메시지를 전송할 객체는 무엇을 원하는가?

   영화를 예매해라

2. 메시지를 수신할 적합한 객체는 누구인가?

   책임을 수행할 정보를 알고 있는 객체에게 책임을 할당하는 것이다. GRASP에서는 이를 INFORMATION EXPERT 패턴이라 부른다.

   여기서 이야기하는 정보는 데이터와 다르다. 책임을 수행하는 객체가 정보를 알고 있다해서, 저장하고 있을 필요는 없다. 객체는 해당 정보를 제공할 수 있는 다른 객체를 알고 있거나 필요한 정보를 계산해서 제공할 수도 있다.

   상영이라는 도메인 개념이 적합하다.

   → 영화에 대한 정보, 상영 시간, 상영 순번처럼 영화 예매에 필요한 다양한 정보를 알고 있다.

    - 메시지를 처리하기 위해 필요한 절차와 구현을 고민해보면 된다.(대충) 스스로 처리할 수 없는 일이 있다면 외부에 도움을 요청해야한다.

      → 이 요청이 외부로 전송해야하는 새로운 메시지가 되고, 최종적으로 이 메시지가 새로운 객체의 책임으로 할당된다.

    - *예매 가격을 계산*하는 작업이 필요하다. 이제 메시지를 책임질 객체를 선택해야한다. 영화라는 도메인 개념이 적합하다.
    - *할인 여부를 판단*하여 가격을 계산해야하는데 영화 도메인 개념이 스스로 처리할 수 없기에 외부의 도움을 요청해야한다. 할인 조건이라는 도메인 개념이 적합하다.

지금까지 살펴본 것처럼 INFORMATION EXPERT 패턴은 객체에게 책임을 할당할 때 가장 기본이 되는 책임할당 원칙이다. 자율성이 높은 객체들로 구성된 협력 공동체를 구축할 가능성이 높아지는 것이다.

### 높은 응집도와 낮은 결합도

우리는 설계를 하다보면 많은 설계가 존재한다는 걸 알고 있는데, 이런 협력 패턴 중에서 높은 응집도와 낮은 결합도를 얻을 수 있는 설계가 있다면 그 설계를 선택해야한다.

예를 들어 Movie가 DiscountCondition에게 혹은 Screening이 DiscountCondition에 할인 여부를 판단하라는 메시지를 전송하는 것의 차이를 살펴보자.

도메인상으로 Movie는 DiscountCondition의 목록을 속성으로 포함하기에 (이미 결합되어있기에) 추가하지 않고도 협력을 완성할 수 있다. 그러나 후자는 추가해야한다.

만일 후자라면, Screening은 영화 요금 계산과 관련된 책임 일부를 안아야할텐데, 그렇다면 Movie가 이 할인 여부를 필요한다는 사실도 알고 있어야한다. 이렇게 되면 응집도가 낮아진다. 따라서 전자의 경우를 선택하는 것이 좋다.

> 조금 억지인 면이 있는듯,,ㅎㅎ

### 창조자에게 객체 생성 책임을 할당하라

GRASP의 CREATOR(창조자) 패턴은 책임 할당 패턴으로 객체를 생성할 책임을 어떤 객체에게 할당할지에 대한 지침을 제공한다.

- B가 A 객체를 포함하거나 참조한다.
- B가 A 객체를 기록한다.
- B가 A 객체를 긴밀하게 사용한다.
- B가 A 객체를 초기화하는데 필요한 데이터를 가지고 있다.(B는 A에 대한 정보 전문가이다.)

이처럼 CREATOR 패턴의 의도는 생성되는 객체와 연결되거나 관련될 필요가 있는 객체에 해당 객체를 생성할 책임을 맡기는 것이다. 이미 존재하는 객체 사이의 관계를 사용하기에 설계가 낮은 결합도를 유지할 수 있다.

Screening은 Reservation의 CREATOR로 선택하는 것이 적절해보인다. 예매 정보를 생성하는 데 필요한 영화, 상영 시간, 상영 순번의 정보 전문가이기 때문이다.

## 구현을 통한 검증

### DiscountCondition 개선하기

변경에 취약한 클래스를 포함하고 있다.

- 새로운 할인 조건 추가
- 순번 조건을 판단하는 로직 변경
- 기간 조건을 판단하는 로직이 변경될 경우

DiscountCondition은 연관성이 없는 기능이나 데이터가 하나의 클래스 안에 뭉쳐져 있어 응집도가 낮다. 응집도가 초래하는 문제를 해결하기 위해 **변경의 이유에 따라 클래스를 분리**해야한다.

변경의 이유가 하나 이상인 클래스에서는 위험 징후를 또렷하게 드러내는 몇가지 패턴이 존재한다.

1. 인스턴스 변수가 초기화되는 시점을 살펴봤을 때 객체의 속성 중 일부만 초기화하고 일부는 초기화되지 않은 상태로 남겨진다.

   → 클래스의 속성이 서로 다른 시점에 초기화되거나 일부만 초기화된다는 것은 응집도가 낮다는 증거다.

2. 메서드들이 인스턴스 변수를 사용하는 방식을 살펴봤을 때, 메서드들이 사용하는 속성에 따라 그룹이 나뉜다면 클래스의 응집도가 낮다고 볼 수 있다.

   → 속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드를 분리해야 한다.

### 타입 분리하기 & 다형성을 통해 분리하기

DiscountCondition의 가장 큰 문제는 순번 조건과 기간 조건이라는 두 개의 독립적인 타입이 하나의 클래스 안에 공존하고 있는 것이다. 두개의 클래스로 분리해야한다.

사실 Movie 입장에서 보면 순번, 기간 조건은 아무런 차이가 없다. 모두 할인 여부를 판단하는 동일한 책임을 수행하고 있을 뿐이다. 따라서 자연스럽게 역할의 개념이 등장한다.

Movie가 구체적인 클래스는 알지 못한 채 오직 역할에 대해서만 결합되도록 의존성을 제한할 수 있다.

역할을 대체할 클래스들 사이에서 구현을 공유해야할 필요가 있다 → 추상 클래스 사용

구현 공유 필요 없이 역할을 대체하는 객체들의 책임만 정의하고 싶다 → 인터페이스 사용

GRASP에서는 이를 POLYMORPHISM 패턴이라 부른다.

하나의 클래스가 여러 타입의 행동을 구현하고 있는 것처럼 보인다면 클래스를 분해하고 POLYMORPHISM 패턴에 따라 책임을 분산시켜라.

### 변경으로부터 보호하기

두 서브 클래스는 서로 다른 이유로 변경된다. 만일 새로운 할인 조건을 추가하는 경우 어떻게 될까? DiscountCondition이라는 추상화가 구체적인 타입을 캡슐화한다.

Movie에 대한 어떤 수정도 필요 없다. 이 처럼 변경을 캡슐화하도록 책임을 할당하는 것을 GRASP에서는 PROTECTED VARIATIONS 패턴이라 부른다.

예측가능한 변경으로 인해 여러 클래스들이 불안정해진다면 PROTECTED VARIATIONS 패턴에 따라 안정적인 인터페이스 뒤로 변경을 캡슐화하라.

### Movie 클래스 개선하기

Movie 또한 할인정책 두가지 타입을 하나의 클래스 안에서 구현하므로 응집도가 낮다.

이 또한 위와 동일한 방식으로 수행하면 된다.

데이터 중심 설계는 데이터와 관련된 클래스의 내부 구현이 인터페이스에 여과없이 노출되므로 캡슐화를 지키기 어려워 응집도가 낮고 결합도가 높아 변경에 취약한 코드가 만들어질 가능성이 높다.

결론은 객체에게 중요한 것은 상태가 아니라 행동이다. 객체지향 설계의 기본은 책임과 협력에 초점을 맞추는 것이다.

### 변경과 유연성

1. 코드를 이해하고 수정하기 쉽도록 최대한 단순하게 설계하는 것이다.
2. 코드를 수정하지 않고도 변경을 수용할 수 있도록 코드를 더욱 유연하게 만드는 것이다.

대부분 전자가 낫고, 유사한 변경이 반복적으로 발생한다면 복잡성이 상승하더라도 유연성을 추가하는 두 번째 방법이 더 좋다.

만일, 할인 정책을 실행 중에 변경할 수 있어야 한다는 요구사항이 추가되었다 하면, 현재는 할인 정책 구현을 위해 상속을 이용하여, 실행 중에 영화의 할인 정책을 변경하기 위해 새로운 인스턴스를 생성 후 필요한 정보를 복사해야한다.

이에 대한 해결방법은 상속대신 합성을 사용하는 것이다. Movie 상속 계층 안에 구현된 할인 정책을 독립적인 DiscountPolicy로 분리 후 Movie에 합성시키면 유연한 설계가 완성된다.

합성을 사용한 예제의 경우 새로운 할인 정책이 추가되더라도, 할인 정책을 변경하는데 필요한 추가적인 코드를 작성할 필요가 없다. 새로운 클래스를 추가하고 클래스의 인스턴스를 Movie의 changeDiscountPolicy 메서드에 추가하면 된다.

```java
Movie movie = new Movie("타이타닉",
												Duration.ofMinutes(120),
												Money.wons(10000),
												new AmountDiscountPolicy(...));
movie.changeDiscountPolicy(new PercentDiscountPolicy(...));
```

실제로 유연성은 의존성 관리의 문제이다. 유연성의 정도에 따라 결합도를 조절할 수 있는 능력은 객체지향 개발자가 갖춰야하는 중요한 기술 중 하나이다.

## 책임 주도 설계의 대안

책임과 객체 사이에서 방황할 때 돌파구를 찾기 위해 선택하는 방법은 최대한 빠르게 목적한 기능을 수행하는 코드를 작성하는 것이다. 코드 상에 명확하게 드러나는 책임들을 올바른 위치로 이동시키는 것이다.

그러나 주의할 점은 코드를 수정 후 겉으로 드러나는 동작이 바뀌어서는 안된다. 캡슐화 향상, 응집도 높이기, 결합도 낮추기는 해야하나 동작은 그대로 유지해야한다.

4장 초반에 개발한 데이터 중심 설계를 리팩터링 하는 과정을 통해 이 방법의 장점을 설명한다.

### 메서드 응집도

데이터 중심으로 설계된 영화 예매 시스템에서 도메인 객체들은 단지 데이터의 집합일 뿐이며 영화 예매를 처리하는 모든 절차는 ReservationAgency에 집중돼있었다.

```java
public class ReservationAgency {
    public Reservation reserve(Screening screening, Customer customer, int audienceCount) {
        Movie movie = screening.getMovie();
        boolean discountable = false;
        for(DiscountCondition condition : movie.getDiscountConditions()) {
            if(condition.getDiscountConditionType() == DiscountConditionType.PERIOD) {
                discountable = screening.getWhenScreened().getDayOfWeek().equals(condition.getDayOfWeek()) &&
                    condition.getStartTime().compareTo(screening.getWhenScreened().toLocalTime()) <= 0 &&
                    condition.getEndTime().compareTo(screening.getWhenScreened().toLocalTime()) >= 0;
            } else {
                discountable = condition.getSequence() == screening.getSequence();
            }

            if (discountable) {
                break;
            }
        }
        Money fee;
        if (discountable) {
            Money discountAmount = Money.ZERO;
            switch(movie.getMovieType()) {
                case AMOUNT_DISCOUNT:
                    discountAmount = movie.getDiscountAmount();
                    break;
                case PERCENT_DISCOUNT:
                    discountAmount = movie.getFee().times(movie.getDiscountPercent());
                    break;
                case NONE_DISCOUNT:
                    discountAmount = Money.ZERO;
                    break;
            }

            fee = movie.getFee().minus(discountAmount);
        } else {
            fee = movie.getFee();
        }

        return new Reservation(customer, screening, fee, audienceCount);
    }
}
```

이 긴 메서드는 유지보수에 부정적 영향을 미친다.

- 어떤 일을 수행하는지 한눈에 파악하기 어려워 전체적으로 이해하는데 너무 많은 시간이 걸린다.
- 하나의 메서드 안에서 너무 많은 작업을 처리하므로 변경이 필요할 때 수정해야할 부분을 찾기 어렵다.
- 메서드 내부의 일부 로직만 수정하더라도 메서드 나머지 부분에서 버그가 발생할 확률이 높다.
- 로직의 일부만 재사용하는 것이 불가능하다.
- 코드를 재사용하는 유일한 방법은 원하는 코드를 복사해서 붙여넣는 것 뿐이므로 코드 중복을 초래하기 쉽다.

객체로 책임을 분배할 때 가장 먼저 해야할 일은 메서드를 응집도 있는 수준으로 분해하는 것이다.

```java
public Reservation reserve(Screening screening, Customer customer, int audienceCount) {
        boolean discountable = checkDiscountable(screening);
        Money fee = calculateFee(screening, discountable, audienceCount);
        return createReservation(screening, customer, audienceCount, fee);
    }
```

수정 후 메서드가 어떤 일을 하는지 한눈에 알아볼 수 있게 됐다.

할인 조건 중 기간 조건을 판단하는 규칙이 변경되거나 금액할인 규칙, 예매 요금을 계산하는 규칙이 변경될 경우 하나의 메서드만 수정하면 된다.

작고, 명확하며 ,한가지 일에 집중하는 응집도 높은 메서드는 변경 가능한 설계를 이끌어 내는 기반이 된다.