## 서론

실무가 이론보다 앞서있는 대표적인 분야 → 소프트웨어 설계, 소프트웨어 유지보수

**실무는** 훌륭한 소프트웨어를 설계하기 위해 필요한 기법과 도구를 지속적으로 발전시켜옴

실무에서 반복적으로 적용되던 기법들을 이론화한 것이 대부분임.

따라서 실무 관점으로(코드를 이용하여) 객체 지향의 다양한 측면을 설명하려 함.

## 티켓 판매 애플리케이션 구현하기

### 조건

- 추첨을 통해 선정된 관람객에게 공연을 무료로 관람할 수 있는 초대장을 발송
- 이벤트에 당첨된 관람객은 초대장을 티켓으로 교환한 후 입장 가능
- 관람객을 입장시키기 전에 이벤트 당첨 여부를 확인해야 하고, 이벤트 당첨자가 아닌 경우, 티켓을 판매한 후 입장시켜야 함.

### 구현

- 이벤트 당첨자에게 발송되는 초대장 구현
- 관람객이 소지품을 보관할 가방 구현
    - 이벤트에 당첨된 관람객 → 현금과 초대장
    - 이벤트에 당첨되지 않은 관람객 → 현금
- 관람객 구현 → 가방
- 매표소 구현 → 판매할 티켓(여러개), 티켓의 판매 금액
- 판매원은 초대장을 티켓으로 교환 or 티켓을 판매 → 매표소를 알고 있어야 함.
- 관람객 소극장에 입장시키는 것 구현

## 무엇이 문제인가

모든 모듈은 제대로 실행돼야 하고, 변경이 용이해야 하며, 이해하기 쉬워야 함.

그러나 작성한 코드는 변경 용이성과 읽는 사람과의 의사소통이라는 목적을 만족시키지 못함.

### 예상을 빗나가는 코드

1. 관람객과 판매원은 소극장의 통제를 받는 수동적인 존재임.
    - 소극장이라는 제 3자가 관람객의 가방을 통제

        → 현실에서는 관람객이 직접 자신의 가방에서 초대장 or 돈을 꺼내 판매원에게 건넴.

    - 소극장이 매표소에 보관 중인 티켓과 현금에 마음대로 접근

        → 판매원은 매표소에 있는 티켓과 돈을 직접 관리

2. 하나의 클래스나 메서드에서 많은 세부사항을 다뤄 코드 작성 & 읽고 이해하는 사람에게 큰 부담을 줌.

### 변경에 취약한 코드

1. 관람객이 현금이 아니라 신용카드를 이용해서 결제한다면?
2. 판매원이 매표소 밖에서 티켓을 판매한다면?

객체 사이의 **불필요한 의존성**으로 인해 객체 변경 후 그 객체를 의존하는 다른 객체를
 변경해야하는 사실이 내포됨.

→ 결합도가 높음.

## 설계 개선하기

기능은 제대로 수행하지만 이해하기 어렵고 변경하기 쉽지 않다.

- Theater가 관람객의 가방, 판매원의 매표소에 직접 접근함.

    → 수동적이므로 의도가 어긋남

- Theater는 Audience, TicketSeller 에 결합됨.

    → 결합도가 높음, 불필요한 의존성

따라서 관람객과 판매원을 능동적인 존재로 만들자!

### 자율성을 높이자

Audience와 TicketSeller가 직접 Bag과 TicketOffice를 처리하는 자율적인 존재가 되도록 설계를 변경하자.

→ 인터페이스와 구현으로 나누고 인터페이스만을 공개함으로써 결합도 낮춤 & 변경하기 쉬운 코드

**TicketSeller**

1. Theater의 enter 메서드에서 TicketOffice에 접근하는 모든 코드를 TicketSeller 내부로 숨긴다.
    - TicketSeller에 getTicketOffice 메서드가 제거 & 능동적으로 수정됨.
    - 즉 캡슐화가 됨. → 객체 사이의 결합도를 추어 설계를 더 쉽게 변경함.
2. Theater의 enter 메서드는 sellTo 메서드를 호출하는 간단한 코드로 바뀜.
3. Theater은 TicketSeller의 인터페이스에만 의존함.
TicketSeller가 내부에 TicketOffice 인스턴스를 포함하고 있다는 사실은 구현 영역에 속함.

**Audience**

1. Bag에 접근하는 모든 로직 Audience 내부로 숨긴다.
    - buy 메서드 추가

        → Audience가 Bag을 직접 처리하기에 외부에서는 더이상 Audience가 Bag을 소유하고 있단 사실을 알 필요가 없음.

    - getBag 메서드 제거 & 능동적으로 수정됨.

### 무엇이 개선되었는가

- 수정된 Audience와 TicketSeller는 능동적으로 소지품을 관리함.
- 변경 용이성 측면에서도 확실히 개선됨.

### 어떻게 한 것인가

- 객체의 자율성을 높이는 방향으로 설계를 개선함.

### 캡슐화와 응집도

- 객체 내부의 상태를 캡슐화하여 메시지를 통해서만 상호작용하도록 만듦.
- Theater는 TicketSeller의 내부는 전혀 알지 못함.
- TicketSeller 또한 Audience의 내부를 전혀 알지 못함.

→ 밀접하게 연관된 작업만 수행, 연관성 없는 작업은 다른 객체에게 위임하는 객체

**응집도가 높음.**

1. 객체 스스로 자신의 데이터를 책임져야 함.
2. 외부의 간섭을 배제하고 메시지를 통해서만 협력해야 함.

### 절차지향과 객체 지향

**절차적 프로그래밍**

프로세스와 데이터를 별도의 모듈에 위치시키는 방식

과거 작성된 코드 관점으로 살펴봤을 때,

Theater의 enter 메서드는 **프로세스**

Audience, TicketSeller, Bag, TicketOffice는 **데이터**

**객체지향 프로그래밍**

데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식

캡슐화를 이용해 의존성을 적절히 관리함으로써 객체 사이의 결합도를 낮춤.

## 책임의 이동

- 기존 절차적 프로그래밍은 Theater가 전체적인 작업을 도맡아 처리
- 객체지향 설계에서는 각 객체가 자신이 맡은 일을 스스로 처리함.

    → 각 객체는 자신을 스스로 책임짐.

불필요한 의존성을 제거함으로써 객체 사이의 결합도를 낮춤.

→ Theater가 몰라도 되는 세부 사항을 Audience와 TicketSeller 내부로 감춰 캡슐화함.

자율성을 높이고 응집도 높임.

### 더 개선할 수 있다.

Bag은 스스로 자기 자신을 책임지지 않고 Audience에 의해 끌려다니는 수동적인 존재

TicketOffice 또한 TicketSeller에 의해 끌려다니는 수동적인 존재

→ 내부 상태에 접근하는 모든 로직을 안으로 캡슐화해서 객체에게 자율성을 부여함.

그러나 TicketOffice의 경우, 자율성을 부여함과 동시에 Audience에 대한 결합도가 상승했다.

따라서 차라리 결합도를 낮추는 게, 유지보수 측면에서 나을 것이라는 판단.

### 그래, 거짓말이다!

현실에서는 수동적인 존재라고 하더라도, 일단 **객체지향의 세계**에서는 모든 것이 능동적이고 자율적인 존재.

이를 **의인화**라 부른다.

## 객체지향 설계

### 설계가 왜 필요한가

설계란 코드를 배치하는 것. 그렇다면 좋은 설계란 무엇일까?

기능을 구현하는 코드를 짜야하는 동시에 나중에도 쉽게 변경할 수 있는 코드를 짜야함.

→ 요구 사항은 항상 변경되기 때문에

→ 코드를 변경할 때 버그가 추가될 가능성이 높기에

- 버그의 가장 큰 문제점은 코드를 수정하려는 의지를 꺾는다.
- 코드 수정을 회피하려는 가장 큰 원인은 두려움이다.

### 객체지향 설계

- 객체 지향 프로그래밍은 의존성을 효율적으로 통제할 수 있는 다양한 방법을 제공

  → 요구사항 변경에 좀 더 수월하게 대응할 수 있는 가능성을 높여줌.

- 객체지향의 세계에서 애플리케이션은 객체들로 구성
- 애플리케이션의 기능은 객체들 간의 상호작용을 통해 구현
- 훌륭한 객체지향 설계란 협력하는 객체 사이의 의존성을 적절하게 관리하는 설계