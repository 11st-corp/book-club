## 협력 & 역할 & 책임

협력: 작업을 수행하고자 필요한 객체들 간의 상호작용

역할: 작업을 수행하는 객체가 담당하는 집합

책임: 협력에 참여하기 위해 객체가 수행하는 행위

### 책임 주도 설계

- 책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법
1. 책임을 할당한다는 것은 메시지의 이름을 결정하는 것과 같다.
    - 예매하라
2. 그 메시지를 처리할 적절한 **객체**를 선택한다.
    
    → 책임을 수행하기 위해 필요한 정보를 충분히 알고 있는 객체를 선택해야한다.
    
    - Screening
3. 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 or 역할을 찾는다.
    - 예매하라 → Screening → 가격을 계산하라
4. 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.
    - 예매하라 → Screening → 가격을 계산하라 → Movie
5. 다음 작업 또한 위의 순서대로 수행한다.

## 응집도와 결합도

응집도: 객체가 얼마나 관련 높은 책임을 할당하고 있는지

결합도: 객체가 다른 객체에 얼마나 의존도를 가지고 있는지

응집도가 높고 결합도가 낮을 수록 코드 유연성이 높아 코드를 변경하기 쉬워진다.

캡슐화의 정도는 응집도와 결합도에 영향을 미친다. 캡슐화를 지킨다면 응집도는 높아지고 결합도는 낮아진다.

## 추상화

복잡한 로직과 변경이 자주 있는 로직을 생략하여 이해하는데 필요한 부분만 남겨두어, 결합도를 낮추고, 응집도는 높이는 설계

### 추상 데이터 타입

추상 데이터 타입은 추상 객체의 클래스를 정의한 것으로

추상 객체에 사용할 수 있는 오퍼레이션을 이용해 규정된다.

데이터 추상화, 정보 은닉, 데이터 캡슐화, 인터페이스 - 구현 분리의 개념들이 모두 녹아들어있다.

이런 타입을 구현하기 위해서는 다음과 같은 프로그래밍 언어의 지원이 필요하다.

- **타입 정의를 선언**할 수 있어야 한다.
- 타입의 인스턴스를 다루기 위해 사용할 수 있는 **오퍼레이션의 집합을 정의**할 수 있어야 한다.
- 제공된 오퍼레이션을 통해서만 조작할 수 있도록 데이터를 **외부로부터 보호**할 수 있어야 한다.
- 타입에 대해 **여러개의 인스턴스를 생성**할 수 있어야 한다.

### 클래스

클래스는 상속과 다형성을 지원하는 데 비해 추상 데이터 타입은 지원하지 못한다.

- 객체지향 프로그래밍 : 상속과 다형성을 지원함
- 객체기반 프로그래밍: 상속과 다형성을 지원하지 않는 추상 데이터 타입 기반의 프로그래밍 패러다임

- 타입 추가라는 변경의 압력이 더 강한 경우 객체지향의 손을 들어줘야 한다.
- 오퍼레이션을 추가하는 것이라면 추상 데이터 타입의 손을 들어줘야 한다.

## 의존성

- 직접 의존성: 한 요소가 다른 요소에 직접 의존 하는 경우
→ PeriodCondition이 Screening에 의존하는 경우
- 간접 의존성: 직접적인 관계는 존재하지 않지만 의존성 전이에 의해 영향이 전파되는 경우
→ 의존성은 PeriodCondition 의 코드 안에 명시적으로 드러나지 않는다.
- 런타임 의존성이 다루는 주제는 객체 사이의 의존성이다.
- 컴파일타임 의존성이 다루는 주제는 클래스 사이의 의존성이다.

### 컨텍스트 독립성

클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이루어져 있다면
 다른 문맥에서 재사용하기가 더 수월해지는데 이를 컨텍스트 독립성이라 한다.

실행 컨텍스트에 대해 알아야 하는 정보를 줄일 수록 결합도가 낮아진다.

## 캡슐화

추상화를 가능케 하는 방법, 복잡한 로직과 변경이 잦은 로직을 숨길 수 있게 한다. 또한

접근 제어자를 통해 인터페이스 상속을 가능케 한다.

## 다형성

상속, 인터페이스 등이 다형성의 구현체이다. 

## 합성 & 인터페이스 상속 vs 클래스 상속
|  | 상속 | 합성 |
| --- | --- | --- |
| 의존성 | 컴파일 타임에 해결 | 런타임에 해결 |
| 관계 | is-a 관계 | has-a 관계 |
| 재사용 명칭 | 화이트 박스 재사용 | 블랙 박스 재사용 |

상속을 받으면 부모 클래스의 내부가 자식 클래스에 공개되므로 화이트 박스이다.

합성은 객체 내부는 공개되지 않고 인터페이스를 통해서만 재사용되므로 블랙박스 재사용이다.

### 합성 & 인터페이스 상속

객체 간의 계층 관계를 표현하고자 하는 것이다. 

이 방식은 코드 재사용을 목적으로 상속하는 게 아닌, 객체 간의 계층 관계를 표현하는 것이 주 목적이다.

코드 재사용은 부수 효과로 따라오는 것이다.

합성과 인터페이스 상속을 하게 되면, 클래스 폭탄을 막을 수 있다.

### 클래스 상속

코드 재사용을 목적으로 하는 상속이다.

부모와 자식 간의 결합도가 매우 높아, 개방-폐쇄 원칙을 위배한다.

→ 부모의 코드를 수정하기 위해 자식의 코드도 확인해야하며, 알지 못하는 부수 효과가 있을 수 있다.

또한 기능을 추가하기 위해서는 부모의 자식들과 비슷한 코드를 한묶음 추가해야하는 불상사가 있을 수 있다.

## 리스코프 원칙

- 클라이언트가 차이점을 인식하지 못하고 기반 클래스의 인터페이스를 통해 서브 클래스를 사용할 수 있어야 한다는 것
- 개방-폐쇄 원칙을 만족하는 설계를 위한 전제 조건

## 개방 - 폐쇄 원칙

- 확장에 대해 열려있다: 애플리케이션의 요구 사항이 변경될 때 이 변경에 맞게 새로운 동작을 추가하여 애플리케이션의 기능을 확장할 수 있다.
- 수정에 대해 닫혀있다: 기존의 코드를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다.
- 개방-폐쇄 원칙을 따르는 설계는 컴파일타임 의존성은 유지하면서, 런타임 의존성의 가능성을 확장하고 수정할 수 있는 구조이다.
- 즉 추상화가 개방-폐쇄 원칙을 가능케 하는 이유다.

## 의존성 역전 원칙

1. 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안된다. 둘 모두 추상화에 의존해야한다.
2. 추상화는 구체적인 사항에 의존해서는 안된다. 구체적인 사항은 추상화에 의존해야한다.

이를 의존성 역전 원칙(Dependency Inversion Principle, DIP)이라 부른다.

> 전통적인 소프트웨어 개발 방법에서는 상위 수준 모듈이 하위 수준의 모듈에 의존하는 그리고 정책이 구체적인 것에 의존하는 경향이 있었기 때문에 ‘역전’ 이라는 단어를 넣었다.
> 

## DRY 원칙

중복 코드를 결정하는 기준은 코드의 모양이 아닌 코드가 변경에 반응하는 방식이다.

## 서브클래싱과 서브타이핑

- 서브 클래싱 (구현 상속 및 클래스 상속)
    - 다른 클래스의 코드를 재사용할 목적으로 상속을 하는 경우
    - 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 없다.
- 서브 타이핑 (인터페이스 상속)
    - 타입 계층을 구성하기 위해 상속을 사용하는 경우
    - 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 있다.
