# 스프링 입문을 위한 자바 객체 지향의 원리와 이해

### 목차

[001. 사람을 사랑한 기술](# 001. 사람을 사랑한 기술)

[002. 자바와 절차적/구조적 프로그래밍](# 002. 자바와 절차적/구조적 프로그래밍)





# 001. 사람을 사랑한 기술

## 1.1. 신기술은 이전 기술의 어깨를 딛고

##### 스프링을 이해하려면 이전의 어떤 기술들을 이해하고 있어야 할까?

- SOA
- CBD
- OOP
- 절차적/구조적 프로그래밍
- 기계어, 어셈블리어



## 1.2. 기계어에서 객체 지향 프로그래밍 언어로

#### 기계어 - 0과 1의 행진 / 너무나 비인간적인 언어

기계어는 기계가 이해하는 유일한 언어로, 2진 숫자인 0과 1로만 표현된다. 기계어 코드는 CPU에 따라 다르다. 즉, 이기종 간에 호환이 불가능하다.

#### 어셈블리어 - 0과 1의 행진을 벗어나 인간 지향으로 / 기계어 니모닉

니모닉(Mnemonic)과 기계어의 일대일 매칭 코드표 = 어셈블리

> 니모닉(Mnemonic)
>
> 어떤 것을 기억하는 데 쉽게 하도록 도움을 주는 것, 또는 쉽게 기억되는 성질. 니모닉은 재사용이 필요할 때 사람의 기억을 돕기 위해 명확하게 선택된 상징이나 상징의 조합을 사용하는 것을 말한다.



#### C언어 - 강력한 이식성 / One Source Multi Object Use Anywhere

#### C++ 언어 - 정말 인간적인 프로그래밍 방법론, 객체 지향

#### 자바 - 진정한 객체 지향 언어

- c++: 객체 지향 개념 도입
- Java: 가상 머신 JVM
  - One Source Multi Object Use Anywhere -> Write Once Use Anywhere
- C#: 가상 머신과 비슷한 공통 언어 런타임 CLR (Common Language Runtime)



## 1.3. 짧은 글, 긴 생각

#### UML을 대하는 자세

> **통합 모델링 언어**(UML : Unified Modeling Language)는 소프트웨어 공학에서 사용되는 표준화된 범용 모델링 언어이다. 이 표준은 UML을 고안한 객체 관리 그룹에서 관리 하고 있다.
>
> UML은 소프트웨어 집약 시스템의 시각적 모델을 만들기 위한 도안 표기법을 포함한다.



#### 당신은 CBD, SOA가 어려운가?

> **CBD(Component Based Development; 컴포넌트 기반 개발)**
>
> CBD는 애플리케이션을 통짜로 개발하지 말고, 애플리케이션을 의미 있는 단위로 구분하고 그 단위를 하나 하나씩 부품으로 개발해 마치 레고 블록을 쌓아 올리듯 부품을 결합해 소프트웨어 제품을 완성하자는 방법론이자 기법이다. 제품이 아니다.
>
> **SOA(Service Oriented Architecture; 서비스 중심 구조, 서비스 지향 구조 )**
>
> SOA는 개발자 입장에서의 개발이 아니라 실제 현실의 업무를 기준으로 개발하자는 사상이다. 제품이 아니다.

##### CBD (Component Based Development), 컴포넌트 기반 개발

애플리케이션을 통짜로 개발하지 말고, 애플리케이션을 의미 있는 단위로 구분하고 그 단위를 하나하나씩 부품으로 개발해 마치 레고 블록을 쌓아 올리듯 부품을 결합해 소프트웨어 제품을 완성하자는 방법론이자 기법.

##### SOA (Service Oriented ARchitecture), 서비스 중심 구조 or 서비스 지향 구조

개발자 입장에서의 개발이 아니라 실제 현실의 업무를 기준으로 개발하자는 사상.



#### 객체 지향의 4대 특성을 누군가에게 설명할 수 있는가?

객체 지향의 4대 특성, 객체 지향 설계 5원칙, 객체 지향의 베스트 프랙티스 모음인 디자인 패턴 등의 개념이 정립



#### 스프링 프레임워크는 사상이면서 또 단일 제품이다

스프링 프레임 워크가 제품이라면 개념은 무엇일까?

바로 **OOP 프레임워크**



##### 스프링 삼각형

IoC/DI, AOP, PSA. 스프링 삼각형은 POJO(Plain Old Java Object)에 세 가지 유형의 진동을 줌으로써 거대한 프레임워크를 완성해냈다.



스프링 프레임워크의 또 다른 아름다움은 엔터프라이즈 애플리케이션을 구현하는 데 필요한 거의 모든 서비스를 지원해준다는 것이다.



## 1.4. 책 출간의 변

#### 우리가 알아야 할 것

- OOP 개념
- 자바 언어의 문법
- 자바가 OOP 개념을 구현한 방식

# 002. 자바와 절차적/구조적 프로그래밍

## 2.1. 자바 프로그램의 개발과 구동

JDK - Java Development Kit / 자바 개발 도구

JRE - Java Runtime Environment / 자바 실행 환경

JVM - Java Virtual Machine / 자바 가상 기계

**자바 개발 도구인 JDK를 이용해 개발된 프로그램은 JRE에 의해 가상의 컴퓨터인 JVM 상에서 구동된다.**

다만 배포되는 JDK, JRE, JVM은 편의를 위해 JDK가 JRE를 포함하고 다시 JRE는 JVM을 포함하는 형태로 배포된다.



#### 자바의 메모리 사용 방식

- 프로그램이 메모리를 사용하는 방식: 코드 실행 영역 / 데이터 저장 영역
- 객체 지향 프로그램의 메모리 사용 방식: 코드 실행 영역 / (스태틱 영역, 스택 영역, 힙 영역)



#### 자바에 존재하는 절차적/구조적 프로그래밍의 유산



#### 다시 보는 main() 메서드: 메서드 스택 프레임

main() 메서드는 프로그램이 실행되는 시작점이다. main() 메서드가 실행될 때 메모리, 특히 T 메모리에는 어떤 일이 일어날까?

> 데이터 저장 영역에 해당하는 static 영역, stack 영역, heap 영역을 T 메모리라고 부른다.
>
> - static 영역
>   - 패키지나 클래스 정보가 올라간다.
>   - 패키지나 클래스는 프로그램 시작과 동시에 모두 올라가는 것이 아니라, 실제로 호출될 때 올라간다.
>   - 그러므로, static (전역) 변수는 읽기 전용이 아닌 경우에는 가능한 사용하지 말아야 한다.
>   - class 영역 혹은 method 영역 이라고도 불린다.
>   - static 영역에 자리잡게되면 JVM이 종료될 때까지 사라지지 않고, 고정된(static) 상태로 유지된다.
> - stack 영역
>   - 여는 중괄호 '{'를 만날 때 마다 스택 프레임이 하나씩 생기고, 닫는 중괄호 '}'를 만나게 되면 스택 프레임이 사라진다. 그러므로 메소드가 실행될 뿐 만 아니라, if문, 반복문, 예외처리를 위한 try문 등도 모두 스택프레임이 생긴다.
>   - stack 내부에서 선언된 지역변수는 stack 영역에 올라간다.
>   - 기본형 타입 변수의 값들은 stack영역에 저장되고, 참조형 타입 변수는 참조값만 저장된다. (이 참조값은 heap 영역에 존재하는 인스턴스(객체)를 가르키는 역할을 한다. 엄격한 표현은 아니지만 인스턴스(객체) 주소값 정도로 이해해도 된다.)
>   - 외부 스택 프레임에서는 내부 스택 프레임의 변수에 접근 하는 것은 불가능하나 그 역은 가능하다. 쉽게 생각하면 메소드안에 for문 스택 프레임을 만든 경우, for문에서는 자신을 호출한 메소드의 변수는 사용가능하나, 메소드에서는 for문에서 선언한 변수를 사용 할 수 없다. 
>   - \+ 메소드를 호출하는 것은 별개의 스택프레임 이기 때문에 스택 프레임을 넘어서 접근할 수 없다.
>   - 쓰레드도 stack 영역에 생기게 된다. 하나의 쓰레드는 내부적으로 별개의 T메모리 구조 static, stack, heap영역을 갖게 된다. 이런 이유로 하나의 쓰레드는 다른 쓰레드로 접근 할 수 없지만, static 영역과 heap 영역은 공유해서 사용 할 수있는 특징을 가지게 된다. (이런 특징이 멀티 프로레스 구조보다 멀티 쓰레드 구조가 메모리를 적게 사용 할 수 있는 이유이다.)
> - heap 영역
>   - 생성된 객체(인스턴스)들이 올라간다.
>   - 인스턴스 필드들은 heap 영역에 올라간다. (이러한 이유로 static한 메소드에서 인스턴스 멤버를 접근할 수가 없다. 어떤 인스턴스 인지도 알 수 없고, 존재하지도 않을 수도 있는 인스턴스를 사용하라는 것이기 떄문이다.)
>   - 메소드들은 static이 아니더라도 굳이 heap에 생기지 않는다. 어차피 같은 로직의 메소드이기 때문에, 여러개 일 필요가 없다.
>   - stack영역에서 참조값을 이용하여 참조형 변수가 heap 영역에 있는 인스턴스를 가르키어 제어 할 수 있게 된다.
>   - 어떤 참조 변수도 힙영역에 있는 인스턴스를 참조하지 않게 된다면, GC(가비지 컬렉터)에 의해 메모리에서 사라지게 된다.
>   - 상속을 이용한 인스턴스를 만들었다면 상위 클래스들의 인스턴스들도 같이 생성된다. (최상위인 Object까지)



```java
	public class Start {
    public static void main(String[] args) {
      System.out.println("Hello OOP!!");
    }
  }
```

1. JRE는 먼저 프로그램 안에 main() 메서드가 있는지 확인한다.

2. main() 메서드의 존재가 확인되면 JRE는 가상의 기계인 JVM에 전원을 넣어 부팅한다.

3. 부팅된 JVM은 목적 파일을 받아 그 목적 파일을 실행한다.

4. JVM은 가장 먼저 java.lang 패키지(모든 자바 프로그램이 반드시 포함하게 되는 패키지)를 T 메모리의 스태틱 영역에 가져다 놓는다.

5. 다음으로 JVM은 개발자가 작성한 모든 클래스와 임포트 패키지 역시 스태틱 영역에 가져다 놓는다.

   > 정리: main() 메서드가 실행되기 전 JVM에서 수행하는 전처리 작업들
   >
   > - java.lang 패키지를 T 메모리의 스태틱 영역에 배치한다.
   > - import된 패키지를 T 메모리의 스태틱 영역에 배치한다.
   > - 프로그램 상의 모든 클래스를 T 메모리의 스태틱 영역에 배치한다.

6. main() 메서드의 스택 프레임이 스택 영역에 할당된다.

7. 메서드 인자(들)의 변수 공간을 할당한다.

8. 명령문 실행



- T 메모리 구조
- java.lang 패키지
- import 패키지와 클래스들
- 메서드 스택 프레임
- JVM
- JRE



## 2.2. 변수와 메모리: 변수! 너 어디 있니?

```java
public class Start 2 {
  public static void main(String[] args) {
    int i;
    i = 10;
    
    double d = 20.0;
  }
}
```

main() 메서드 스택 프레임 안에 밑에서부터 차곡차곡 변수 공간을 마련한다.



## 2.3. 블록 구문과 메모리: 블록 스택 프레임

```java
public class Start3 {
  public static void main(String[] args) {
    int i = 10;
    int k = 20;
    
    if(i == 10) {
      int m = k + 5;
      k = m;
    } else {
      int p = k + 10;
      k = p;
    }
    
    // k = m + p;
  }
}
```

if ~ else 블록, 여는 중괄호를 만나면 스택 프레임이 시작되는데 여기서 만들어지는 스택 프레임은 메서드의 스택 프레임이 아니라 if 문, 그것도 참인 블록의 스택 프레임이다. if 불록 중 참일 때의 블록을 종료하는 닫는 중괄호를 만나면 if 블록 스택 프레임은 스택 영역에서 사라진다. 이때 if 블록 스택 프레임 안에 상주하던 변수의 저장 공간도 함께 사라진다. main() 메서드 스택 프레임을 소멸시키는 블록 마침 기호인 닫는 중괄호에서는 T 메모리 소멸, JVM 가동 중지, JRE가 사용했던 시스템 자원을 운영체제에 반납한다.



## 2.4. 지역 변수와 메모리: 스택 프레임에 갇혔어요!

변수는 메모리에 있다? O

T 메모리 세 개의 영역 중 어디에? '세 군데 모두'

그런데 세 군데 각각에 있는 변수는 각기 다른 목적을 가진다. 그리고 각각의 이름도 지역 변수, 클래스 멤버 변수, 객체 멤버 변수로 다르다.

- 지역 변수는 스택 영역에서 일생을 보낸다. 그것도 스택 프레임 안에서 일생을 보내게 된다. 따라서 스택 프레임이 사라지면 함께 사라진다.
- 클래스 멤버 변수는 스태틱 영역에서 일색을 보낸다. 스태틱 영역에서 한번 자리 잡으면 JVM이 종료될 때까지 고정된(static) 상태로 그 자리를 지킨다.
- 객체 멤버 변수는 힙에서 일생을 보낸다. 객체 멤버 변수들은 객체와ㅏ 함께 가비지 컬렉터라고 하는 힙 메모리 회수기에 의해 일생을 마치게 된다.

```java
public static void main(String[] args) {
  if (true) {
    int i = 1;
    System.out.println(i); // 살행됨
  }
  
  System.out.println(i) // 참조 불가능 = 에러
  
}
```

**"외부 스택 프레임에서 내부 스택 프레임의 변수에 접근하는 것은 불가능하나 그 역은 가능하다"**



## 2.5. 메서드 호출과 메모리: 메서드 스택 프레임 2

```java
public class Start4 {
  public static void main(String[] args) {
    int k = 5;
    int m;
    
    m = square(k);
  }
  
  private static int square(int k) {
    int result;
    
    k = 25;
    
    result = k;
    
    return result;
  }
}
```

메서드 호출이 일어나면 무조건 호출되는 메서드의 스택 프레임이 T 메모리 스택 영역에 새로 생성된다. square() 메서드 스택 프레임에는 반환값을 저장할 변수 공간이 맨 아래, 그다음으로 인자를 저장할 변수 공간, 그리고 마지막으로 메서드의 지역 변수가 자리 잡는다.

주목해야 할 것은 main() 메서드가 가진 변수 k와 square() 메서드가 가진 변수 k가 이름만 같지 실제로는 서로 별도의 변수 공간이라는 것이다. 이것을 전문 용어로 Call By Value(값에 의한 호출)라 한다.



square() 메서드 내의 실행 명령문에서는 T 메모리 안에 존재하는 main() 메서드의 지역 변수를 참조할 수 있을 것 같지만 그건 자바 스펙을 마드신 분들이 금지시켜 뒀다.

1. 그것이 이치에 맞기 때문이다. 메서드는 서로의 고유 공간인데, 서로 침범하면 무단 침입으로 자바 월드에 문제를 유발할 수 있기 때문이다.
2. 포인터 문제 때문이다. square() 메서드에서 main() 메서드 내부의 지역변수 m에 접근한다고 하면 m의 위치를 명확히 ㅇ알아야 하는데, 그 위치를 명확히 알기 위해서는 바로 m 변수의 메모리 위치, 즉 포인터라고 읽고 메모리 주소 값이라 이해해야 하는 그 값을 알아야 한다.
3. 예제의 코드는 square() 메서드를 main() 메서드 혼자서 호출하는 코드지만 실전에서 사용되는 메서드는 다양한 곳으로부터 호출된다. 이때 호출하는 메서드 내부의 지역 변수를 호출당하는 쪽에서 제어할 수 있게 코드를 만들려면 결국 포인터를 주고받아야 한다.



## 2.6. 전역 변수와 메모리: 전역 변수 쓰지 말라니까요!

```java
public class Start5 {
  static int share;
  
  public static void main(String[] args) {
    share = 55;
    
    int k = fun(5, 7);
    
    System.out.println(share);
  }
  
  private static int fun(int m, int p) {
    share = m + p;
    
    return m - p;
  }
}
```

코드를 보면 share 변수에 static 키워드가 붙어있다. 그래서 share 변수는 T 메모리의 스태틱 영역에 변수 공간이 할당된다. 그것도 Start5 클래스 안에 정의됐으니 해당 클래스가 T 메모리 스태틱 영역에 배치될 때 그 안에 share 변수가 클래스의 멤버로 공간을 만들어 저장된다.

##### 지역 변수와 전역 변수

- 스택 프레임에 종속적인 지역 변수
- 스택 프레임에 독립적인 전역 변수

전역 변수는 코드 어느 곳에서나 접근할 수 있다고 해서 전역 변수라고 하며, 여러 메서드들이 공유해서 사용한다고 해서 공유 변수라고도 한다.

전역 변수는 필할 수 있다면 즐기지 말고 피해야 할 존재다. 다만 읽기 전용으로 값을 공유해서 전역 상수로 쓰는 것은 적근 추천한다. 가장 대표적인 전역 상수 후보로는 원주율을 나타내는 PI값 등이 있다.



## 2.7. 멀티 스레드 / 멀티 프로세스의 이해

멀티 스레드(Multi Thread)의 T 메모리 모델은 스택 영역을 스레드 개수만큼 분할해서 쓰는 것이다.

멀티 프로세스는 다수의 데이터 저장 영역, 즉 다수의 T 메모리를 갖는 구조다.

멀티 프로세스는 각 프로세스마다 각자의 T 메모리가 있고 각자 고유의 공간이므로 서로 참조할 수 없다. 그에 반해 멀티 스레드는 하나의 T 메모리만 사용하는데 스택 영역만 분할해서 사용하는 구조다.

멀티 프로세스는 하나의 프로세스가 다른 프로세스의 T 메모리 영역을 절대 침범할 수 없는 메모리 안전한 구조이지만 메모리 사용량은 그만큼 크다.

멀티 스레드는 하나의 T 메모리 안에서 스택 영역만 분할한 것이기 때문에 하나의 스레드에서 다른 스레드의 스택 영역에는 접근할 수 없지만 스태틱 영역과 힙 영역은 공유해서 사용하는 구조다. 따라서 멀티 프로세스 대비 메모리를 적게 사용할 수 있는 구조다.



```java
public class Start6 extends Thread {
    static int share;

    public static void main(String[] args) {
        Start6 t1 = new Start6();
        Start6 t2 = new Start6();

        t1.start();
        t2.start();
    }

    public void run() {
        for (int count = 0; count < 10; count++) {
            System.out.println(share++);

            try {sleep(10000);}
            catch (InterruptedException e) {}
        }
    }
}
```

```
1
0
2
2
3
4
5
6
7
7
8
9
10
10
```



## 2.8. STS(또는 이클립스)를 이용해 T 메모리 영역 엿보기





## 2.9. 정리 - 객체 지향은 절차적/구조적 프로그래밍의 어깨를 딛고

**메서드를 만들 때는 순서도 또는 의사 코드를 작성하는 것이 좋다.**

능력이 된다면 UML 액티비티 다이어그램을 그리는 것도 좋긴 하지만 메서드의 로직을 표현할 때는 순서도가 더 직관적인 것 같다.

NS 다이어그램, 나시 슈나이더만 다이어그램(Nassi-Shneiderman diagram)



- 스태틱: 클래스의 놀이터
- 스택: 메서드의 놀이터
- 힙: 객체의 놀이터

